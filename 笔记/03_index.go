package main

func main(){

}

/*
复合类型

1.指针
	每个变量有两层含义：变量的内存，变量的地址
	var a int = 10
	a    //变量的内存，内存的内容
	&a   //变量的地址，内存外面的编号，地址，指针

	保存某个变量的地址，需要指针类型   *int保存int地址，**int保存*int地址
	声明（定义），定义只是特殊的声明
	定义一个变量p，类型为*int
	var p *int
	p = &a    指针指向谁，就把谁的地址赋值给指针变量，p指向a
	*p = 666  *p操作的不是p的内存，是p所指向的内存（就是a）

	当p没有合法指向的时候，不能赋值，如
	var p * int
	p = nil
	*p = 666    这是错误操作，因为没有给p指向 &a

	q := new(int)  //自动推导类型
	*q = 777

2.数组
	同一个类型的集合
	var id [50]int

	数组定义：[10]int和[5]int是不同类型；[数字]，这个数字作为数组元素个数，必须是常量
		下标可是常量或变量
	var a [10]int

	全部初始化
	var a [5]int = [5]int{1,2,3,4,5}
	自动推导初始化
	b := [5]int{1,2,3,4,5}
	部分初始化，没有初始化的元素，自动赋值为0
	c := [5]int{1,2,3}

	指定某个元素初始化
	d := [5]int{2:10,4:11}

	比较，只支持 == 或 != ，比较每个元素是不是都一样；两个数组比较，类型要一样

	赋值，同类型的数组可以赋值


	生成随机数
		设置种子，只需一次
		如果种子参数一样，每次运行程序产生的随机数都一样
		rand.Seed(time.Now().UnixNano()) //以当前系统时间作为种子参数
		for i :=0;i<5;i++{
			fmt.Println(rand.Intn(100)) //100以内的随机数；很大的随机数用Int
		}

	数组作为函数参数，是值传递，实参数组的每个元素给形参数组拷贝一份，形参数组是实参数组的复制品
	当用数组指针做函数参数，操作是同一个数组
	func modify(p *[5]int){
		(*p)[0] = 66
	}
	modify(&array)

3.切片
	切片作为函数参数的时候是引用传递
	切片和数组的区别
	数组[5]里面的长度是固定的一个常量，数组不能修改长度，len和cap永远都是一样的
	切片[]里面为空，或者为...，切片的长度或容量可以不固定

	初始化
	自动推倒类型，同时初始化
	s := []int{1,2,3,4}
	借助make函数，格式make(切片类型,长度,容量)
	s := make([]int,5,10)

	append函数，追加，在原切片末尾添加元素
		会只能的底层容量数组容量增长，一旦超过原底层容量，通常以2倍容量重新分配底层数组，并复制原来的数据
	copy函数
		copy(dstSlice,srcSlice)


4.map字典，印射
	初始化
	var m1 = map[int]string //定义一个变量，类型为map
	 m2 := make[map[int]string] //通过make创建
	 m3 := make[map[int]string,10] //通过make创建，可以指定长度
	m3[1] = "mike"
	m3[2] = "go"
	超过容量，自动扩充
	初始化，键值唯一
	m4 := map[int]string{1:"midke",2:"go",3:"c++"}
	赋值-如果已经存在的key值，修改内容
	追加-map底层扩容，和append类似

	map当函数参数是引用传递








*/
